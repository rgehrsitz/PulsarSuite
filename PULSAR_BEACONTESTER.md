# Pulsar/Beacon and BeaconTester: End-to-End Testing Framework

## Overview

This document explains the relationship between Pulsar/Beacon and BeaconTester, and provides guidance on using them together to create a complete end-to-end testing solution for rule-based applications.

## Components

### Pulsar

Pulsar is a rule compiler that takes YAML rule definitions and generates C# code for Beacon applications. It includes:

- YAML rule parsing
- Rule validation and dependency analysis
- Code generation for rule execution
- AOT (Ahead of Time) compilation support

### Beacon

Beacon is the runtime application generated by Pulsar. It:

- Processes input data through rules
- Produces output based on rule conditions
- Uses Redis for input/output communication
- Supports temporal conditions (events over time)

### BeaconTester

BeaconTester is a testing framework for Beacon applications. It:

- Analyzes rule definitions to generate test scenarios
- Simulates inputs via Redis
- Validates outputs against expectations
- Generates test reports

## Workflow

The end-to-end workflow involves these steps:

1. **Define Rules**: Create YAML files defining your rules, conditions, and actions
2. **Compile Beacon**: Use Pulsar to compile the rules into a Beacon application
3. **Generate Tests**: Use BeaconTester to analyze the rules and generate test scenarios
4. **Run Beacon**: Start the Beacon application with Redis
5. **Execute Tests**: Run the tests against the Beacon instance
6. **Analyze Results**: Generate and review test reports

## Communication Flow

```mermaid
[BeaconTester] <-- Redis --> [Beacon]
    |                           |
    |                           |
    v                           v
[Test Reports]              [Rule Execution]
```

- BeaconTester sets input values via Redis keys (input:*)
- Beacon processes the inputs through rules
- Beacon sets output values via Redis keys (output:*)
- BeaconTester validates outputs against expected values


## Test Generation

BeaconTester's test generation analyzes:

- Rule conditions to determine valid input ranges
- Rule dependencies to ensure correct execution order
- Temporal conditions to create multi-step test scenarios

For each rule, it typically generates:

- Positive test cases (inputs that should trigger the rule)
- Negative test cases (inputs that should not trigger the rule)
- Dependency tests (ensuring rules that depend on others work correctly)
- Temporal tests (for rules with conditions over time)

## Known Issues and Solutions

### RedisService.cs Template Issue

#### Problem

The RedisService.cs template in Pulsar.Compiler can have issues with C# pattern matching syntax, causing compilation errors when generating a Beacon application. The most significant issue is in the `SetOutputsAsync` method, which incorrectly handles type checking and casting.

This causes various compilation errors when the Beacon application is built:

```csharp
An expression of type 'double' cannot be handled by a pattern of type 'bool'
```

Additionally, the template file may not be properly copied during the Beacon generation process, resulting in a malformed file with multiple opening braces after the class declaration.

#### Solution

The issue is fixed using our MSBuild-based build process that automatically replaces the problematic generated file after Pulsar runs:

1. A corrected version of RedisService.cs is maintained in the build directory as `RedisService.cs.fixed`

2. The BuildBeacon target in full.e2e.build replaces the generated file with our fixed version:

   ```xml
   <!-- Replace the generated RedisService.cs with our fixed version -->
   <PropertyGroup>
     <RedisServicePath>$(BeaconOutputDir)/Beacon/Beacon.Runtime/Services/RedisService.cs</RedisServicePath>
     <FixedRedisServicePath>$(MSBuildThisFileDirectory)/RedisService.cs.fixed</FixedRedisServicePath>
   </PropertyGroup>
   
   <!-- Use our completely rewritten RedisService.cs to avoid template processing issues -->
   <Copy SourceFiles="$(FixedRedisServicePath)" DestinationFiles="$(RedisServicePath)" OverwriteReadOnlyFiles="true" />
   ```

This approach ensures that the Beacon application compiles successfully without requiring manual intervention.

For more details on this issue, see the [Pulsar bugs documentation](Pulsar/bugs.md).

## Example Usage

### 1. Define Rules (temperature_rules.yaml)

```yaml
rules:
  - name: HighTemperatureRule
    description: "Detects high temperature readings"
    conditions:
      - type: comparison
        sensor: temperature_f
        operator: GreaterThan
        value: 85
    outputs:
      - key: high_temperature
        value: true
```

### 2. Compile Beacon

```bash
dotnet run --project Pulsar.Compiler beacon --config=system_config.yaml --rules=temperature_rules.yaml --output=./Beacon
```

### 3. Generate Tests

```bash
dotnet run --project BeaconTester.Runner -- generate --rules=temperature_rules.yaml --output=test_scenarios.json
```

### 4. Run Beacon

```bash
cd ./Beacon/Beacon.Runtime && dotnet run
```

### 5. Execute Tests

```bash
dotnet run --project BeaconTester.Runner -- run --scenarios=test_scenarios.json --output=test_results.json
```

### 6. Generate Report

```bash
dotnet run --project BeaconTester.Runner -- report --results=test_results.json --output=report.html --format=html
```

## Best Practices

1. **Rule Design**:

   - Keep rules focused on single responsibilities
   - Clearly define dependencies between rules
   - Use descriptive names for rules and outputs

2. **Test Configuration**:

   - Adjust timeout and polling settings for temporal rules
   - Use monitoring mode during development
   - Include both positive and negative test cases

3. **Validation Strategy**:

   - Validate expected outputs from each rule
   - Test edge cases for numeric conditions
   - Include dependency testing for complex rule sets

## Summary

The Pulsar/Beacon and BeaconTester ecosystem provides a complete solution for:

1. Defining rules in a clear, declarative format
2. Compiling rules into efficient, executable code
3. Automatically generating comprehensive test scenarios
4. Validating rule behavior through end-to-end testing
5. Generating reports for analysis and documentation

This integrated approach ensures that rules behave as expected and makes it easy to maintain and extend rule-based systems with confidence.
