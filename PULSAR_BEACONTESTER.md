# Pulsar/Beacon and BeaconTester: End-to-End Testing Framework

## Overview

This document explains the relationship between Pulsar/Beacon and BeaconTester, and provides guidance on using them together to create a complete end-to-end testing solution for rule-based applications.

## Components

### Pulsar
Pulsar is a rule compiler that takes YAML rule definitions and generates C# code for Beacon applications. It includes:
- YAML rule parsing
- Rule validation and dependency analysis
- Code generation for rule execution
- AOT (Ahead of Time) compilation support

### Beacon
Beacon is the runtime application generated by Pulsar. It:
- Processes input data through rules
- Produces output based on rule conditions
- Uses Redis for input/output communication
- Supports temporal conditions (events over time)

### BeaconTester
BeaconTester is a testing framework for Beacon applications. It:
- Analyzes rule definitions to generate test scenarios
- Simulates inputs via Redis
- Validates outputs against expectations
- Generates test reports

## Workflow

The end-to-end workflow involves these steps:

1. **Define Rules**: Create YAML files defining your rules, conditions, and actions
2. **Compile Beacon**: Use Pulsar to compile the rules into a Beacon application
3. **Generate Tests**: Use BeaconTester to analyze the rules and generate test scenarios
4. **Run Beacon**: Start the Beacon application with Redis
5. **Execute Tests**: Run the tests against the Beacon instance
6. **Analyze Results**: Generate and review test reports

## Communication Flow

```
[BeaconTester] <-- Redis --> [Beacon]
    |                           |
    |                           |
    v                           v
[Test Reports]              [Rule Execution]
```

- BeaconTester sets input values via Redis keys (input:*)
- Beacon processes the inputs through rules
- Beacon sets output values via Redis keys (output:*)
- BeaconTester validates outputs against expected values

## Test Generation

BeaconTester's test generation analyzes:
- Rule conditions to determine valid input ranges
- Rule dependencies to ensure correct execution order
- Temporal conditions to create multi-step test scenarios

For each rule, it typically generates:
- Positive test cases (inputs that should trigger the rule)
- Negative test cases (inputs that should not trigger the rule)
- Dependency tests (ensuring rules that depend on others work correctly)
- Temporal tests (for rules with conditions over time)

## Example Usage

### 1. Define Rules (temperature_rules.yaml)
```yaml
rules:
  - name: HighTemperatureRule
    description: "Detects high temperature readings"
    conditions:
      - type: comparison
        sensor: temperature_f
        operator: GreaterThan
        value: 85
    outputs:
      - key: high_temperature
        value: true
```

### 2. Compile Beacon
```bash
dotnet run --project Pulsar.Compiler beacon --config=system_config.yaml --rules=temperature_rules.yaml --output=./Beacon
```

### 3. Generate Tests
```bash
dotnet run --project BeaconTester.Runner -- generate --rules=temperature_rules.yaml --output=test_scenarios.json
```

### 4. Run Beacon
```bash
cd ./Beacon/Beacon.Runtime && dotnet run
```

### 5. Execute Tests
```bash
dotnet run --project BeaconTester.Runner -- run --scenarios=test_scenarios.json --output=test_results.json
```

### 6. Generate Report
```bash
dotnet run --project BeaconTester.Runner -- report --results=test_results.json --output=report.html --format=html
```

## Best Practices

1. **Rule Design**:
   - Keep rules focused on single responsibilities
   - Clearly define dependencies between rules
   - Use descriptive names for rules and outputs

2. **Test Configuration**:
   - Adjust timeout and polling settings for temporal rules
   - Use monitoring mode during development
   - Include both positive and negative test cases

3. **Validation Strategy**:
   - Validate expected outputs from each rule
   - Test edge cases for numeric conditions
   - Include dependency testing for complex rule sets

## Summary

The Pulsar/Beacon and BeaconTester ecosystem provides a complete solution for:
1. Defining rules in a clear, declarative format
2. Compiling rules into efficient, executable code
3. Automatically generating comprehensive test scenarios
4. Validating rule behavior through end-to-end testing
5. Generating reports for analysis and documentation

This integrated approach ensures that rules behave as expected and makes it easy to maintain and extend rule-based systems with confidence.
