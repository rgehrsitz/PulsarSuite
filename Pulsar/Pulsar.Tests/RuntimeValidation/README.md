# Runtime Validation Tests for Pulsar

This directory contains test infrastructure for validating the runtime execution of Beacon code generated by Pulsar. These tests go beyond just validating the Pulsar code generator - they attempt to compile and execute the generated code to ensure it works as expected.

## Current Status

The test infrastructure has been implemented and is ready for testing. We've addressed several issues with the code generation and compilation process to make the tests more reliable.

## Test Categories

The test suite is organized into three main categories:

### 1. Real Rule Execution Tests

These tests validate that rules compile correctly and produce the expected outputs when executed:

- **SimpleRule_ValidInput_SetsOutput**: Tests a basic rule that performs simple arithmetic
- **ComplexRule_ValidInput_SetsOutput**: Tests a rule with complex nested conditions
- **DebugRule_FromTestData_Executes**: Uses a minimal debug rule to verify the pipeline works

### 2. Performance Benchmark Tests

These tests measure the performance characteristics of the rule engine:

- **Benchmark_IncreasingRuleCount_MeasuresScalability**: Tests how performance scales with the number of rules
- **Benchmark_IncreasingRuleComplexity_MeasuresPerformanceImpact**: Tests how performance is affected by rule complexity
- **Benchmark_ConcurrentRuleExecution_MeasuresThroughput**: Tests the throughput under concurrent execution

### 3. Memory Usage Tests

These tests monitor memory consumption during extended rule execution:

- **ExtendedExecution_MonitorsMemoryUsage**: Runs rules over a long period to detect memory leaks
- **HighInputChurn_MonitorsMemoryStability**: Tests memory stability with rapidly changing inputs
- **CircularBuffer_VerifiesNoMemoryLeak**: Specifically tests the circular buffer implementation for leaks

## Architecture

The tests use a `RuntimeValidationFixture` which:

1. Spins up a Redis container for testing
2. Dynamically generates rule YAML files with different characteristics
3. Compiles these rules into a .NET assembly using the Pulsar compiler
4. Loads the assembly dynamically for testing
5. Executes rules and analyzes the results

## Usage

Run all runtime validation tests:

```bash
dotnet test --filter "Category=RuntimeValidation"
```

Run memory tests:

```bash
dotnet test --filter "Category=MemoryUsage"
```

Run a specific test:

```bash
dotnet test --filter "FullyQualifiedName=Pulsar.Tests.RuntimeValidation.RealRuleExecutionTests.DebugRule_FromTestData_Executes"
```

## Debugging Tips

If tests are failing, check:

1. Redis connection - Ensure Docker is running and ports aren't conflicting
2. Rule YAML format - Ensure rules follow the expected format with proper indentation
3. System config - Make sure all sensors used in rules are listed in `validSensors`
4. Build output - Check the logs for compilation errors
5. Redis data - Use `redis-cli` to verify that data is being written/read correctly

## Future Improvements

1. Add stress tests with thousands of rules
2. Test multi-threading and parallel rule execution more thoroughly
3. Add profiling to identify performance bottlenecks
4. Simulate network conditions and latency for Redis operations
5. Test with more complex rule dependencies and feedback loops